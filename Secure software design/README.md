# [Secure Software Design Specialization](https://www.coursera.org/specializations/secure-software-design#courses)

<!-- TOC -->

- [Course 1. Software Design as an Element of the Software Development Lifecycle](#course-1-software-design-as-an-element-of-the-software-development-lifecycle)
    - [Week 1](#week-1)
        - [Thinking](#thinking)
    - [Week 2](#week-2)
        - [Software Development Life Cycle](#software-development-life-cycle)
            - [Waterfall (Каскадная модель)](#waterfall-%D0%BA%D0%B0%D1%81%D0%BA%D0%B0%D0%B4%D0%BD%D0%B0%D1%8F-%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C)
            - [V-Shape Waterfall (V-модель, разработка через тестиование))](#v-shape-waterfall-v-%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C-%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0-%D1%87%D0%B5%D1%80%D0%B5%D0%B7-%D1%82%D0%B5%D1%81%D1%82%D0%B8%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)
            - [Waterfall with feedback (каскадная модель с обратной связью)](#waterfall-with-feedback-%D0%BA%D0%B0%D1%81%D0%BA%D0%B0%D0%B4%D0%BD%D0%B0%D1%8F-%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C-%D1%81-%D0%BE%D0%B1%D1%80%D0%B0%D1%82%D0%BD%D0%BE%D0%B9-%D1%81%D0%B2%D1%8F%D0%B7%D1%8C%D1%8E)
            - [Spiral (спиральная модель)](#spiral-%D1%81%D0%BF%D0%B8%D1%80%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F-%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C)
            - [XP (экстремальное программирование)](#xp-%D1%8D%D0%BA%D1%81%D1%82%D1%80%D0%B5%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)
            - [Agile (гибкая методология разработки)](#agile-%D0%B3%D0%B8%D0%B1%D0%BA%D0%B0%D1%8F-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D1%8F-%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B8)
                - [Dynamic systems development method (метод разработки динамических систем)](#dynamic-systems-development-method-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4-%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B8-%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D1%85-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC)
            - [Таблица: момент определения требований к системе в описанных методологиях](#%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D0%B0-%D0%BC%D0%BE%D0%BC%D0%B5%D0%BD%D1%82-%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F-%D1%82%D1%80%D0%B5%D0%B1%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B9-%D0%BA-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B5-%D0%B2-%D0%BE%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D1%8F%D1%85)
            - [Выводы](#%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4%D1%8B)
        - [What happens in Design](#what-happens-in-design)
            - [Additional Resource](#additional-resource)
    - [Week 3](#week-3)
        - [Design in different SDLCs](#design-in-different-sdlcs)
            - [Дизайн на примере разработки по каскадной модели](#%D0%B4%D0%B8%D0%B7%D0%B0%D0%B9%D0%BD-%D0%BD%D0%B0-%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80%D0%B5-%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B8-%D0%BF%D0%BE-%D0%BA%D0%B0%D1%81%D0%BA%D0%B0%D0%B4%D0%BD%D0%BE%D0%B9-%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D0%B8)
            - [Дизайн в Agile модели разработки](#%D0%B4%D0%B8%D0%B7%D0%B0%D0%B9%D0%BD-%D0%B2-agile-%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D0%B8-%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B8)
            - [Additional Resource](#additional-resource)
        - [Interfacing with requirements and implementation](#interfacing-with-requirements-and-implementation)
            - [Additional Resource](#additional-resource)
    - [Week 4](#week-4)
        - [The role of architecture in design](#the-role-of-architecture-in-design)
            - [Additional Resource](#additional-resource)
        - [Permitted activities that can cause problems](#permitted-activities-that-can-cause-problems)
- [Course 2. Software Design as an Abstraction](#course-2-software-design-as-an-abstraction)
    - [Week 1](#week-1)
        - [Intro](#intro)
            - [Вывод](#%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4)
            - [Additional Resource](#additional-resource)
                - [Уровни абстракции](#%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D0%B8-%D0%B0%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%86%D0%B8%D0%B8)
        - [Вид с высоты птичьего полета](#%D0%B2%D0%B8%D0%B4-%D1%81-%D0%B2%D1%8B%D1%81%D0%BE%D1%82%D1%8B-%D0%BF%D1%82%D0%B8%D1%87%D1%8C%D0%B5%D0%B3%D0%BE-%D0%BF%D0%BE%D0%BB%D0%B5%D1%82%D0%B0)
            - [Additional Resource](#additional-resource)

<!-- /TOC -->

## Course 1. [Software Design as an Element of the Software Development Lifecycle](https://www.coursera.org/learn/software-design-development-life-cycle/home/welcome)

### Week 1

#### [Thinking](https://www.coursera.org/learn/software-design-development-life-cycle/lecture/C34KA/thinking)
Лектор привел пример из своего опыта: он подготавливал речи для высокопоставленного офицера и в то время была наслуху концепция всеобщего качества ([TQM](https://ru.wikipedia.org/wiki/%D0%92%D1%81%D0%B5%D0%BE%D0%B1%D1%89%D0%B5%D0%B5_%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BA%D0%B0%D1%87%D0%B5%D1%81%D1%82%D0%B2%D0%BE%D0%BC)), которую сформулировали на японских промышленных предприятиях. Одной из характерных черт этой концепции является пошагово описанные и регламентирванные процессы, выполнять которые могут любые подготовленные квалифицированные рабочие и на выходе будет одинаково качественный результат.

Лектора попросили подготовить похожее описание процесса написания речи. Очевидно, что процесс написания речи отличается от технологического процесса конкретного производства: в одном случае понадобится прибегнуть к библиотечным источникам, в другом позвонить в одну кампанию, в третьем - в другую; вопросы, которые будут ставится перед писателем каждый раз будут отличаться.

Далее декларируется тот факт, что невозможно придумать список поверки системы, выполнение которой гарантирует 100% защищенность этой системы. Создание устойчивых к атакам систем требует способности адаптироваться, требует умения думать.

### Week 2

#### [Software Development Life Cycle](https://www.coursera.org/learn/software-design-development-life-cycle/lecture/9uGpf/whats-an-sdlc)

- это множество стадий, через которые проект проходит на протяжении своей жизни.
> [additional resource about SDLC](https://www.tutorialspoint.com/sdlc/sdlc_overview.htm)

##### Waterfall (Каскадная модель)
1956, Herbert Benington, [Waterfall](https://en.wikipedia.org/wiki/Waterfall_model)

![Каскадная модель](https://www.seowebsitedesign.com/wp-content/uploads/2012/12/waterfall-model-software.png "Каскадная модель")

- под **Requirements** традионно понимают проблемы, которые требуется решить.
- **Design** первое приближение решения проблемы.
- **Implementation** стадия, на которой дизайн воплощается в коде инструкций, которые в состоянии выполнить компьютер.
- на стадии **Verification** запуски готовой программы используются для проверки корректности работы (решает ли программа поставленные проблемы).
- как только программа получена пользователями, скорректирована и адаптирована для запуска, наступает стадия **Maintenance**.

> [Стандарт ISO, описывающий процессы жизненного цикла программного обеспечения - построен на каскадной модели](https://ru.wikipedia.org/wiki/ISO/IEC_12207:2008)

Преимущества:
- последовательное выполнение этапов проекта в строгом фиксированном порядке
- позволяет оценивать качество продукта на каждом этапе

Недостатки:
- отсутствие обратных связей между этапами
- не соответствует реальным условиям разработки программного продукта

##### [V-Shape Waterfall (V-модель, разработка через тестиование)](https://en.wikipedia.org/wiki/V-Model_(software_development))
![V-модель](content/v-model.jpg "V-модель")

На каждой стадии V-модели происходит тестирование результата этой стадии. Является одной из основных практик экстремального программирования.

##### Waterfall with feedback (каскадная модель с обратной связью)

![Каскадная модель с обратной связью](content/feedback.jpg "Каскадная модель с обратной связью")

Эта модель допускает, что на каждой стадии возможен возврат к предыдущей и ее переделка с учетом вновь открытых обстоятельств.
> почему то лектор говорит (5:43), что "К сожалению, единственное появление фазы требований и отсутствие стрелок обратной связи к фазе требований означает, что требования должны быть правильными с первого раза." хотя стрелка к требованиям есть


##### [Spiral (спиральная модель)](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%80%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C)
![Спираль](content/spiral.jpg "спираль")

Каждый виток спирали соответствует созданию фрагмента или версии программного обеспечения, на нём уточняются цели и характеристики проекта, определяется его качество и планируются работы следующего витка спирали.

Каждый виток разбит на 4 сектора:
- определение целей
- оценка альтернатив, оценка и разрешение рисков
- разработка и тестирование
- планирование следующей итерации, доставка пользователю текущей версии

Недостатком здесь является то, что клиент и пользователи могут видеть на ранней стадии, какую форму принимает программное обеспечение.

Последующие фазы требований используют обратную связь с клиентами, и это приводит к продукту, более адаптированному к потребностям пользователей. Кроме того, это дает клиентам и пользователям больше времени, чтобы понять влияние программного обеспечения на их бизнес-процессы.

Таким образом, клиенты и пользователи не должны пытаться представить все требования сразу. Обучение, которое происходит от итерации к итерации, дает лучшие требования к качеству.

##### [XP (экстремальное программирование)](https://ru.wikipedia.org/wiki/%D0%AD%D0%BA%D1%81%D1%82%D1%80%D0%B5%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)

![Экстремальное программирование](content/xp.jpg "Экстремальное программирование")

Основные приёмы XP (по первому изданию книги Extreme programming explained):

- короткий цикл обратной связи (Fine-scale feedback)
- разработка через тестирование (Test-driven development)
- игра в планирование (Planning game)
- заказчик всегда рядом (Whole team, Onsite customer): представитель заказчика ежедневно находится в команде
- парное программирование (Pair programming): один пишет "тактический код", который чинит тест; второй же смотрит боллее широко и может увидеть лучший путь решения проблемы
- непрерывный, а не пакетный процесс
- непрерывная интеграция (Continuous integration)
- рефакторинг (Design improvement, Refactoring)
- частые небольшие релизы (Small releases)
- понимание, разделяемое всеми
- простота проектирования (Simple design)
- метафора системы (архитектура)
- коллективное владение кодом (Collective code ownership) или выбранными шаблонами проектирования (Collective patterns ownership)
- стандарт оформления кода (Coding standard or Coding conventions)
- социальная защищённость программиста (Programmer welfare): 40-часовая рабочая неделя (Sustainable pace, Forty-hour week)

Требования к системе здесь не отсутсвуют: они должны быть выражены в терминах тестов.

**XP wisdom: feature without a test is not a feature**

##### [Agile (гибкая методология разработки)](https://ru.wikipedia.org/wiki/%D0%93%D0%B8%D0%B1%D0%BA%D0%B0%D1%8F_%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D1%8F_%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B8)

- это итеративный процесс, в котором каждая итерация имеет общие характеристики, такие как анализ требований, проектирование и тестирование.

![Гибкая методология разработки](content/agile.jpg "Гибкая методология разработки")


###### [Dynamic systems development method (метод разработки динамических систем)](https://ru.wikipedia.org/wiki/DSDM)

Относится к Agile семейству методологий.

![Метод разработки динамических систем](content/dsdm.jpg "Метод разработки динамических систем")

Принципы:
- вовлечение пользователя - это основа ведения эффективного проекта, где разработчики делят с пользователями рабочее пространство и поэтому принимаемые решения будут более точными
- команда должна быть уполномочена принимать важные для проекта решения без согласования с начальством
- частая поставка версий результата, с учётом такого правила, что «поставить что-то хорошее раньше - это всегда лучше, чем поставить всё идеально сделанное в конце». Анализ поставок версий с предыдущей итерации учитывается на последующей
- главный критерий - как можно более быстрая поставка программного обеспечения, которое удовлетворяет текущим потребностям рынка. Но в то же время поставка продукта, который удовлетворяет потребностям рынка, менее важна, чем решение критических проблем в функционале продукта
- разработка - итеративная и инкрементальная. Она основывается на обратной связи с пользователем, чтобы достичь оптимального с экономической точки зрения решения
- любые изменения во время разработки - обратимы
- требования устанавливаются на высоком уровне прежде, чем начнётся проект
- тестирование интегрировано в жизненный цикл разработки
- взаимодействие и сотрудничество между всеми участниками необходимо для его эффективности

##### Таблица: момент определения требований к системе в описанных методологиях
![](content/table_requirements.jpg "")

##### Выводы
1. Дизайн системы представлен в каждой методологии управления жизненным циклом разработки ПО
2. В то время как жизненный цикл разработки ПО становится все более адаптивным, гибким, дизайн проектируется с возрастающей частотой

***
*Мои заметки*

- Не очень понятно, почему лектор обсуждает Agile и XP на одном уровне. У меня всегда было примерно такое представление: Agile это класс (технологии разработки ПО), общая сущность, а XP же это инстанс этого класа.

- не упомянута интересная [методология чистой комнаты](https://ru.wikipedia.org/wiki/Cleanroom_Software_Engineering)
Как раз она может поспорить с утверждением лектора о том, что невозможно создать чек лист, который гарантирует безопасность и надежность системы.
Еще есть [книга](https://www.semanticscholar.org/paper/Structured-programming-theory-and-practice-Linger-Mills/b5f49f1899bfd6e4a2a1ba92dbebceefead87f50), где судя по тому, что мне сказали, математически доказывается как раз противоположное этому утверждению лектора.

![Методология чистой комнаты](content/cleanroom.jpg "Методология чистой комнаты")

***

#### [What happens in Design](https://www.coursera.org/learn/software-design-development-life-cycle/lecture/4mUqd/what-happens-in-design)



![Дизайн как промежуточная стадия между требованиями и реализацией](content/designBtw.jpg "Дизайн как промежуточная стадия между требованиями и реализацией")

Можно взглянуть на требования, дизайн и реализацию как на серию трансформаций языка:
- **требования** описываются естественным языком (но желательно в терминах доменной области, которые одназначно определены)

- **дизайн** описывается различными способами (в лекции приводится в пример UML, но я думаю, формальные методы тоже можно отнести сюда); дизайн показывает, как можно выполнить требования; хороший язык дизайна должна позволять проверять дизайн  - т.е. тот, кто знаком с данным языком, мог посмотреть на дизайн и понять, насколько дизайн соответствует требованиям и возможно или нет реализовать такой дизайн
> [Modeling languages](https://en.wikipedia.org/wiki/Modeling_language)

- **реализация** говорит на языке конкретных технологий и в конечном счете представляет собой машиннй код, написанный для конкретной программно-аппаратной архитектуры

Какой конкретно продукт получится на выходе фаз **дизайн** и **реализация** зависит от множества факторов (например, от того, кто решает задачу, какие инструменты использует и т.д.) - и это вносит неопределенность.

![Неопределенность дизайна и реализации](content/designs.jpg "Неопределенность дизайна")

##### [Additional Resource](https://en.wikipedia.org/wiki/Software_design)

### Week 3

#### Design in different SDLCs

##### Дизайн на примере разработки по каскадной модели

Сначала группа людей на протяжении многих встреч разрабатывает требования, утверждает и подписывает их в виде **документа**. Затем требования используются для создания дизайна системы (часто теми же самыми людьми).

При этом неизбежно приходится уточнять и изменять исходные требования, что глава команды разработки принимает неохотно из-за опасений критики со стороны пользователей системы.

Также зачастую дизайнеры игнорируют некоторые требования и делают так, как сами считают нужным (создают дизайны\архитектуры, которые были необходимы исходя из общей цели систем, но при этом они не основаны на каких либо формально зафиксированных требованиях).

Также в случае, если команда дизайнеров - это та же команда, что разрабатывала требования и та же команда что будет писать код, то часто она может делать довольно грубый дизайн потому, что:
- она составляла требования
- она знает точно для чего нужна система
- она может исправить неточности дизайна кодом

Так случается потому, что в этом случае нет способа проверить соответствие дизайна требованиям.

Решением может быть нанять другую команду, которая изучит требования и дизайн и сможет проверить их соответсвие друг другу. Это довольно затратно.

Также другая команда не может так хорошо чувствовать требования\дизайн\реализацию как это чувствует так команда, которая уже несколько лет работает над ними - она будет сконцетрирована на поверхностных и очевидных несоответствиях.

В конечном счете, это приводит к тому, что никто не знает, хорош ли дизайн.

**Возникает вопрос: можно ли в принципе при работе в каскадной модели создать хороший дизайн?**
Ответ: да, но очень редко.

Для проверки дизайна есть способ: написать его упрощенный (в несущественных деталях) прототип. Тогда на стадии реализации возникнет минимальное количество вопросов.

![Проверка прототипом дизайна помогает реализации](content/check_design.jpg "Проверка прототипом дизайна помогает реализации")

##### Дизайн в Agile модели разработки
Agile основывается на частых поставках ценных фич командой разработки. Циклы итераций варьируются от нескольких недель до нескольких месяцев в зависимости от сложности проекта, размера команды и критичности разрабатываемой системы (каков потенциальный ущерб от неправильной работы системы).

В Agile есть шаг дизайна, но при этом он не фиксируется строго в документах (как это делается в каскадной модели).
В начале каждой итерации поставки ценной фичи разрабатывается грубый, общий дизайн, который требует взгляда на цели системы в целом. Далее в процессе работы будут созданы дизайны небольших модулей кода.


![Agile design](content/agile_design.jpg "Agile design")

##### [Additional Resource](http://wiki.c2.com/?WhatIsSoftwareDesign)
Проводится параллель между проектированием и изготовлением инженерных систем\деталей машин\изделий и созданием программного обеспечения.

Рассматривается следующий посыл: инженерному проекту соответсвует листинг исходного кода (не UML диаграмма или любое другое высокоуровневое представление проекта системы (дизайна)), а сборочной линии соответствует компилятор. Проект - исходный код, а "сборочная линия на заводе" - это компилятор.
Программное обеспечение - это не исходный код, это последовательность нулей и единиц, которая запускается на компьютерах.

Далее критикуется набор статей\высказываний конкретно об этом посыле и о разработке ПО в целом.
По мнению автора, шагу поддержки ПО во всех существующих методологиях разработки (кроме XP) уделяется недостаточно внимания.

Главная мысль автора статьи: в разработке ПО достаточно сложно выделить "дизайн" и "конечный продукт", скорее это множество точек на пути к конечному продукту и одна и та же точка может быть как продуктом предудущей стадии, так и дизайном следующей <. . . . .>.
"Дизайн" и "продукт" не зафиксированные во Вселенной точки, а движение, в котором мы надеемся что очередное изменение принесет больше пользы, чем вреда.

#### Interfacing with requirements and implementation

В общем можно сказать, что дизайн преобразует требования в понятную для реализации форму.
Первый вопрос, который появляется при разработке дизайна системы: как передать все необходимые знания, которые есть у того, кто разработал требования, тому, кто разрабатывает дизайн (не всегда это одно и то же лицо).
Часто требования нуждаются в переформулировании, например, когда это просто набор запросов разных ответственных людей.

**Для того, чтобы начать разрабатывать дизайн, необходимо иметь целостную картину системы, понимать, как одни ее части зависят от других.**
Например, можно начать со следующего:
- разделить мысленно систему по тем частям, функционал которых тесно связан (думаю, доменная модель здесь кстати)
> лектор называет это fault lines

![Fault lines](content/fault_lines.jpg "Fault lines")
- оценить риски проекта
> это зависит уже от личного опыта: если ты хорошо разбираешься в БД, то часть системы, связанная с БД вряд ли несет большие риски

![С чего начать](content/design_start.jpg "С чего начать")

После того, как это сделано, логичным следующим шагом будет смягчение рисков: узать больше о конкретном риске.
Следующий шаг - создание прототипа системы\ее части.

![Смягчение рисков](content/mitigate_risks.jpg "Смягчение рисков")

##### Additional Resource
1. [Requirements Versus Design: It’s All Design](http://www.its-all-design.com/requirements-versus-design-its-all-design/)
> пост, в котором требования рассмотриваются неотделимыми от дизайна: как только ты, как разработчик\аналитик, начинаешь задавать уточняющие вопросы заказчику о деталях работы системы, ты начинаешь создавать дизайн, а не просто записываешь список под диктовку заказчика
2. [The Web Design Process](https://www.lifewire.com/web-design-process-3466386)
> короткий пост о этапах проектирования веб сайта

### Week 4

#### The role of architecture in design

В некоторых случаях дизайн системы разбивают на высокоуровневый и низкоуровневый (например, в Agile-цикле разработки, где вначале всей разработки создается всеобъемлющий общий дизайн, а в начале каждой итерации проектируется кусочек системы, который будет реализован в этой итерации):

![Agile design](content/agile_design.jpg "Agile design")

Этот низкоуровневый дизайн обычно понимается как дизайн, а высокоуровневый - как архитектура.

Далее лектор иллюстрирует на примерах из личного опыта, что безопасть системы в большей мере зависит от принятых архитектурных решений, чем от низкоуровневого дизайна.
![Архитектура и вопросы безопасности](content/security_and_architecture_in_design.jpg "Архитектура и вопросы безопасности")

##### Additional Resource
[Software Architecture (общий набросок для микроконтроллерных систем)](http://www.the-software-experts.com/e_dta-sw-design-high-level.php)


#### Permitted activities that can cause problems

Лектор приводит пример: однажды один человек случайно отправил email на всю компанию, другие люди стали ему отвечать (также на всю компанию), как итог email система была серьезно нагружена.

Это пример разрешенной (для пользователя) активности в системе, которая, тем не менее, может привести к серьезным проблемам.

Еще один пример из разработки ПО: если следовать принципу модульности, код, отвечающий за одну задачу (использовать который возможно требуется в разных местах), лежит только в одном месте. При этом, если в этом месте он сломан - сломается весь код, который его использует.
> [Open SSL бага Heartbleed отлично демонистрирует такой вариант](https://ru.wikipedia.org/wiki/Heartbleed)

Главая идея, которую старается донести лектор (также, как и в первых лекциях): невозможно составить чек лист, следуя которому, получишь защищенную от атак или проблем, подобных описанному примеру с рассылкой, систему - необходимо думать, кем и как система будет использоваться и как это может нанести вред.
Такой чек лист может иметь только вид:
- подумай хорошо (кто может эксплуатировать определенное поведение системы)
- подумай еще раз

Очевидно, что наличии еще одного человека (помимо дизайнера\архитектора системы), который может проверить систему, весьма полезно.

Примеры, использование которых надо проанализировать с точки зрения безопасности:
1. drug'n'drop произвольного текстового файла в разрабатываемое приложение: сможет ли приложение корректно распарсить его и не представляет ли угрозу специально подготовленный файл
2. разработка сетевого адаптера: сможет ли он корректно обработать некорректные пакеты, подготовленные злоумышленником
3. некоторый веб скрапер: страницы представляют собой просто гипер текст (здесь угроза аналогично первому примеру)
4. архивация\распаковка файла: архивация не несет существенных угроз, тогда как распаковка - да, может быть опасна, ведь архив может быть поврежден (намеряно или нет)
5. бинарный блоб в БД: хранение безопасно, обработка - нет

> забавно, что вопросы про это были в тесте за предыдущую неделю

Идемпотентная транзакция:
```
DELETE FROM USER WHERE USERID = 12345
````

Неидемпотентная транзакция:
```
DELETE FROM USER WHERE USERID = (SELECT MAX(USERID) FROM USER)
```


## Course 2. [Software Design as an Abstraction](https://www.semanticscholar.org/paper/Structured-programming-theory-and-practice-Linger-Mills/b5f49f1899bfd6e4a2a1ba92dbebceefead87f50)

### Week 1

#### Intro

Дизайн в SDLC - это фаза жизненного цикла, расположенная между фазой формирования требований и фазой реализации (на вход этой фазы приходят требования, на выходе - инструкции для разработчиков):
```
Requirements --> Design --> Implementation
```

Но также к дизайну можно относится как к верхнеуровневой реализации.

Первое очевидное преимущество такого взгляда: дизайн позволяет сжато описать очень широкую область, которую в виде кода сложно удержать в голове целиком:

![Дизайн как верхнеуровневая реализация](content/little_drawning.jpg "Страница диаграмм может быть эквивалентом 10 000 строк кода")

Второе - цена изменений в дизайне и в коде реализации, который следует дизайну:

![Архитектор Райт о трудозатратах разных инструментов](content/sledge_hammer.jpg "Архитектор Райт о трудозатратах разных инструментов")

Лектор отмечает здесь, что такой вгляд на дизайн и код реализации - когда код следует дизайну - является важным и верным.
В отличии от обратного случая, когда дизайн следует за кодом реализации (например, когда по договору к системе должна быть приложена UML диаграмма и это - единственная цель дизайна).
В таком случае проще всего сгенерировать диаграмму из кода, но это не поможет созданию проекта.

Также, визуализация дизайна в виде рисунка\диаграммы задействует части нашего мозга, ответсвенные за визуальное восприятие. Во многих языка слова "Я вижу" означают "Я понимаю".

Иллюстрация этого утверждения: как проще и быстрее представить лабиринт и выход из него - рисунок или текст:

![2 способоа восприятия](content/maze.jpg "2 способа восприятия")

##### Вывод
**Дизайн - это нечто большее, чем просто процесс, который преобразует требования к системе в инструкции для разработчиков для реализации: это шаг, на котором достигается понимание требований.**

Именно поэтому надо хорошо работать над дизайном.

##### Additional Resource
[ABSTRACTION IN DESIGN](https://aojajena.wordpress.com/2012/04/19/abstraction-in-design/)

Плохой дизайн часто является причиной плохо работающей системы.

Автор сетует на то, что мало кто понимает проблемы дизайна не поверхностно и причина, по его мнению, в образовании: люди могут в течение часов и дней изучать полиморфизм, наследование, тактические шаблоны кода, но часто забывают об **абстракции**, о том, как вычленять суть процессов реального мира.

###### Уровни абстракции

Можно посмотреть на дерево целиком:

![Высокий уровень абстракции](content/abs_tree_1.jpg "Дерево в целом")

А можно спуститься чуть ниже и увидеть дерево как переплетение ветвей:

![Чуть более низкий уровень абстракции](content/abs_tree_2.jpg "Переплетение ветвей")

Если спуститься дальше, снова увидим дерево (маленькое, но дерево):

![Еще более низкий уровень абстракции](content/abs_tree_3.jpg "Снова дерево")

Можно двигаться и в сторону увеличения уровня абстракции:

![Более высокий уровень абстракции](content/abs_tree_4.jpg "Лес")


Во всех случаях разный уровень абстракции привидет к дизайну разных моделей, которые будут отражать существенные детали для каждого уровня абстакции.


#### Вид с высоты птичьего полета

В SDLC цена исправления ошибки текущего этапа на следующем этапе увеличивается на порядок:

![Цена исправления ошибки](content/correcting_cost.jpg "Цена исправления ошибки")

Поэтому с этой точки зрения качественный дизайн невероятно важен и помогает экономить ресурсы.

Намного проще на этапе дизайна понять, подходит (римские числа: методы Number могут быть реализованы для RomanNumeral) или нет (автомобиль: очевидно, что методы Number не несут смысла для Automobile), чем на этапе реализации:

![Пример легкости исправления на этапе дизайна](content/uml_ex.jpg "Пример легкости исправления на этапе дизайна")

Диарамма позволяет так легко увидеть неконсистентность дизайна по 2 причинам:
1. это визуальное изображение
2. она абстрактна

##### Additional Resource
[Designing Abstractions](http://web.stanford.edu/~ouster/CS349W/lectures/abstraction.html)

Самый фундаментальный элемент информатики:

- НЕ РАЗРАБОТКА АЛГОРИТМОВ: компьютеры достаточно быстры чтобы сглаживать проблемные места в алгоритмах большинства программных задач
- самая большая проблема это управление сложностью:
    - технологии позволяют на строить системы большего размера, чем мы способны понять
    - сложность ПО растет со временем и система становится хрупкой (опасно вносить изменения)
- фундаментальная проблема: разбиение большой системы на меньшие части, каждая из которых может быть понята в изоляции от других
- термин "абстракция" применяется к этим меньшим частям в этой статье

Хорошая абстракция:
- минимальная площадь поверхности для максимального объема: простой интерфейс скрывает большую сложность реализации
- простота использования: меньше печатать, меньши тратить усилий на изучение
- переиспользование
- "сокрытие" или "разделение интересов":
    - скрывает решения дизайна (например, комплексный алгоритм\структура данных) за простым интерфейсом
    > классическая статья [On the Criteria To Be Used in Decomposing Systems into Modules](content/criteria_for_modularization.pdf)

Пример не очень хорошей абстракции - списки:
- List_First, List_Next, List_End
- альтернатива: напрямую использовать указатели в базовых структурах данных
- нет какой то комплексной сложности, которую скрывает интерфейс
- интерфейс не так прост, как указатели
- интерфейс добавляет в систему сложность
- но может быть полезен с точки зрения разрешения построения операций более высокого уровня, которые будут работать для различных видов списков, таких как сортировка

Хорошая абстракций - пайпы в Unix системах:
- индивидуальный фильтр читает из stdio, пишет в stdout
- консольные программы соединяют такие фильтры в единый пайп
- сложность реализаций сокрыта (grep, wc, set и т.д.)
- легко переиспользовать
- уменьшение кода: маленький скрипт коммандной строки может сделать очень многое

Как вычленить хорошую абстракцию:
- факты первичны: изучите много кода, вычлените общие задачи
- разделите общие случаи:
    - мощные интерфейсы в конечном итоге нуждаются в большом количестве функций, но большинство из них используются не очень часто
    - определите общий случай: "что самое простое это может быть?"
    - сначала сделайте общий случай как можно более простым, а затем найдите способ поддержать частные случаи, не усложняя общий случай
    - упростите изучение общего случая, не изучая причудливые функции; подобрать дополнительные функции по одному, по мере необходимости
- разрешите настройку\расширение, но не делайте обязательной
- минимизируйте обработку ошибок